/****************************************************************************************************************************************
 * © 2016 Daqri International. All Rights Reserved.                                                                                     *
 *                                                                                                                                      *
 *     NOTICE:  All software code and related information contained herein is, and remains the property of DAQRI INTERNATIONAL and its  *
 * suppliers, if any.  The intellectual and technical concepts contained herein are proprietary to DAQRI INTERNATIONAL and its          *
 * suppliers and may be covered by U.S. and Foreign Patents, patents in process, and/or trade secret law, and the expression of         *
 * those concepts is protected by copyright law. Dissemination, reproduction, modification, public display, reverse engineering, or     *
 * decompiling of this material is strictly forbidden unless prior written permission is obtained from DAQRI INTERNATIONAL.             *
 *                                                                                                                                      *
 *                                                                                                                                      *
 *                                                                                                                                      *
 *     File Purpose:        Creates an infinitely scrollable view of cells.                                                             *
 *                          The cells are created at runtime and resused to allow an inifinite amount of content.                       *
 *                                                                                                                                      *
 *     Guide:               Assign the controller property to provide information about each row.                                       *
 *                          Change the ContentOffset property to change the scroll position.                                            *
 *                                                                                                                                      *
 ****************************************************************************************************************************************/

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using DAQRI.Internal;

namespace DAQRI {

    [RequireComponent (typeof (RectTransform))]
    public class ScrollView : MonoBehaviour {

        private class NoPrefabException : Exception {}

        /// <summary>
        /// All cells will be instantiated from this prefab.
        /// To have the cell respond to the reticle dwell, add a Button component to the prefab's hierarchy.
        /// The button will be automatically linked to the reticle dwell event.
        /// Note that because of this automatic linking, having other buttons on the cell is not supported.
        /// </summary>
        public GameObject cellPrefab;

        /// <summary>
        /// The controller provides the information needed for each row.
        /// It also allows you to respond to cell click events, 
        /// which are generated by the reticle dwelling on a cell's Button component.
        /// You must assign a controller to use the scroll view.
        /// </summary>
        public ScrollViewController controller;

        /// <summary>
        /// The space between each cell.
        /// </summary>
        public float cellSpacing = 4.0f;

        private float _contentOffset = 0;

        /// <summary>
        /// The content offset indicates the vertical scroll position.
        /// A content offset of zero corresponds to the top of the scroll view.
        /// An increase in content offset reveals the bottom content.
        /// A decrease reveals the top content.
        /// Scrolling behavior is done via setting this property.
        /// </summary>
        /// <value>The content offset.</value>
        public float ContentOffset {
            get {
                return _contentOffset;
            }
            set {
                _contentOffset = Math.Max(Math.Min (value, MaxContentOffset ()), 0);
                didOffsetChange = true;
            }
        }

        /// <summary>
        /// If true, the view will change height on Start so that only a whole number of cells are showing.
        /// If a cell is partially displayed, the height will shrink so that cell is out of view.
        /// If false, no height adjustment occurs.
        /// </summary>
        public bool fitHeightToCells = true;

        private bool isCellPrefabValid = true;
        private bool didOffsetChange = true;

        private GameObject content;

        private List<ScrollViewCellWrapper> visibleCellsUnordered = new List<ScrollViewCellWrapper> ();
        private List<ScrollViewCellWrapper> availableCells = new List<ScrollViewCellWrapper> ();
        private List<int> visibleRows = new List<int> ();


        #region Cached Properties

        private float _cellHeight = 0;
        private float CellHeight {
            get {
                if (_cellHeight == 0 && cellPrefab != null) {
                    _cellHeight = cellPrefab.GetComponent<RectTransform> ().rect.height;
                }

                return _cellHeight;
            }
        }

        private float _contentViewHeight = 0;
        private float ContentViewHeight {
            get {
                if (_contentViewHeight == 0) {
                    _contentViewHeight = content.GetComponent<RectTransform> ().rect.height;
                }

                return _contentViewHeight;
            }
        }

        #endregion


        void Awake () {
            content = GetComponentInChildren<Mask> ().gameObject;

            foreach (Transform child in content.transform) {
                Destroy(child.gameObject);
            }

            if (fitHeightToCells) {
                RectTransform rectTransform = GetComponent<RectTransform> ();

                Vector2 sizeDelta = rectTransform.sizeDelta;
                sizeDelta.y = sizeDelta.y - (content.GetComponent<RectTransform> ().rect.height - ContentViewHeightToFitCells ());
                rectTransform.sizeDelta = sizeDelta;
            }
        }

        void Start () {
            if (controller == null) {
                Debug.LogError ("Scroll view needs a controller to provide information about the rows. Please add one.");
            }

            isCellPrefabValid = ValidateCellPrefab ();
        }

        void Update () {
            if (!didOffsetChange || !isCellPrefabValid || controller == null) {
                return;
            }

            didOffsetChange = false;

            UpdateVisibleRowsList ();

            List<int> rowsNeedingCells = new List<int> (visibleRows);

            for (int i = 0; i < visibleCellsUnordered.Count; i++) {
                ScrollViewCellWrapper cell = visibleCellsUnordered [i];

                if (visibleRows.Contains (cell.currentRow)) {
                    SetTransformYPosition (cell.gameObject.GetComponent<RectTransform> (), PositionForCellAtRow (cell.currentRow));
                    rowsNeedingCells.Remove (cell.currentRow);

                } else {
                    visibleCellsUnordered.Remove (cell);
                    availableCells.Add (cell);
                    cell.gameObject.SetActive (false);
                    i--; // Since we removed an element, repeat this index
                }
            }

            foreach (int rowNeedingCell in rowsNeedingCells) {
                ScrollViewCellWrapper cell;

                if (availableCells.Count > 0) {
                    cell = availableCells [0];
                    cell.gameObject.SetActive (true);

                    availableCells.RemoveAt (0);

                } else {
                    try {
                        cell = NewCellWrapper ();

                    } catch (NoPrefabException) {
                        return; // No point continuing if cell can't be created
                    }
                }

                cell.currentRow = rowNeedingCell;
                SetTransformYPosition (cell.gameObject.GetComponent<RectTransform> (), PositionForCellAtRow (rowNeedingCell));

                visibleCellsUnordered.Add (cell);

                if (cell.cellText != null) {
                    cell.cellText.text = controller.TextForRow (rowNeedingCell);
                }

                controller.ConfigureCellForRow (cell.gameObject, rowNeedingCell);
            }
        }

        #region Public

        /// <summary>
        /// Returns the maximum allowed content offset.
        /// </summary>
        /// <returns>The maximum content offset.</returns>
        public float MaxContentOffset () {
            return OffscreenContentHeight ();
        }

        /// <summary>
        /// Indicates whether the scrolling behavior is needed.
        /// If all rows can fit within the bounds of the scroll view, scrolling is not needed.
        /// </summary>
        /// <returns><c>true</c> if this instance has scrollable content; otherwise, <c>false</c>.</returns>
        public bool HasScrollableContent () {
            return (OffscreenContentHeight () > 0);
        }

        /// <summary>
        /// Indicates whether there is offscreen content above the currently visible content.
        /// </summary>
        /// <returns><c>true</c> if there is offscreen content above the visible rows; otherwise, <c>false</c>.</returns>
        public bool CanScrollUp () {
            return (ContentOffset > float.Epsilon);
        }

        /// <summary>
        /// Indicates whether there is offscreen content below the currently visible content.
        /// </summary>
        /// <returns><c>true</c> if there is offscreen content below the visible rows; otherwise, <c>false</c>.</returns>
        public bool CanScrollDown () {
            return Math.Abs (ContentOffset - MaxContentOffset ()) > float.Epsilon;
        }

        #endregion


        #region Controller Wrappers

        private string TextForRow (int row) {
            if (controller == null || row >= controller.NumberOfRows ()) {
                return string.Empty;
            }

            return controller.TextForRow (row);
        }

        private void ConfigureCell (GameObject cell, int row) {
            if (controller == null) {
                return;
            }

            controller.ConfigureCellForRow (cell, row);
        }

        private int NumberOfUserDefinedRows () {
            if (controller == null) {
                return 0;
            }

            int controllerValue = controller.NumberOfRows ();

            return Math.Max (controllerValue, 0);
        }

        #endregion


        #region Helpers

        private float TotalContentHeight () {
            return NumberOfUserDefinedRows () * (CellHeight + cellSpacing) + cellSpacing; // Extra cell spacing to leave room at top of list
        }

        private float OffscreenContentHeight () {
            float offscreenHeight = TotalContentHeight () - ContentViewHeight;
            return Math.Max (offscreenHeight, 0);
        }

        private float PositionForCellAtRow (int row) {
            float firstVisibleCellPosition = ((ContentOffset - cellSpacing) % (CellHeight + cellSpacing)); // Extra cell spacing to leave room at top of list

            // Multiply by -1 since y increases vertically and we want to layout from top cell downwards 
            float cellPosition = firstVisibleCellPosition - ((row - FirstVisibleRow ()) * (CellHeight + cellSpacing));

            return cellPosition;
        }

        private int FirstVisibleRow () {
            float effectiveContentOffset = Math.Max (ContentOffset - cellSpacing, 0); // Takes into account the spacing at the top of the first cell
            int firstVisibleRow = (int)(effectiveContentOffset / (CellHeight + cellSpacing));

            return firstVisibleRow;
        }

        /// <summary>
        /// Returns the hypothetical number of rows that are visible in the scroll view
        /// when the content offset is zero.
        /// This is only based on view sizes, and has nothing to do with the actual number of user-defined rows.
        /// Note that when the content offset is non-zero, 
        /// the actual number of visible rows may be different than the value returned here.
        /// </summary>
        /// <returns>The number of rows visible when the content offset is zero.</returns>
        private int NumberOfRowsFittingInViewAtTop () {
            float spaceNeededForRow = CellHeight + cellSpacing;
            int rowsFittingInView = (int)Math.Ceiling (((ContentViewHeight - cellSpacing) / spaceNeededForRow));

            return rowsFittingInView;
        }

        /// <summary>
        /// Returns the maximum possible number of visible rows for any content offset.
        /// Note the actual number of visible rows may be less,
        /// based on the content offset and cell alignment with the scroll view.
        /// </summary>
        /// <returns>The max number of visible rows possible for any content offset.</returns>
        private int MaxPossibleVisibleRows () {
            int rowsFittingInView = NumberOfRowsFittingInViewAtTop ();

            // If all rows fit in the view, no need to add offscreen buffer cells
            if (rowsFittingInView == NumberOfUserDefinedRows ()) {
                return NumberOfUserDefinedRows ();
            }

            return rowsFittingInView + 1;
        }

        /// <summary>
        /// Returns the suggested height for the content view to display only whole cells.
        /// The returned value will always be smaller or equal to the current height.
        /// </summary>
        /// <returns>The suggested view height to show only whole cells.</returns>
        private float ContentViewHeightToFitCells () {
            float spaceNeededForRow = CellHeight + cellSpacing;
            int rowsFittingInView = (int)((ContentViewHeight - cellSpacing) / spaceNeededForRow);

            // Reset this here, since it's likely that the content height will be changed after this method is called
            _contentViewHeight = 0;

            return spaceNeededForRow * rowsFittingInView + cellSpacing;
        }

        /// <summary>
        /// Creates a new cell wrapper object.
        /// The cell game object is setup and ready to be configured for the specific row.
        /// </summary>
        /// <returns>A new cell wrapper.</returns>
        private ScrollViewCellWrapper NewCellWrapper () {
            if (cellPrefab == null) {
                throw new NoPrefabException ();
            }

            GameObject cell = Instantiate(cellPrefab);
            cell.transform.SetParent (content.transform);

            RectTransform cellRectTransform = cell.GetComponent<RectTransform> ();
            cellRectTransform.anchorMin = new Vector2 (0.5f, 1.0f);
            cellRectTransform.anchorMax = new Vector2 (0.5f, 1.0f);
            cellRectTransform.pivot = new Vector2 (0.5f, 1.0f);
            cellRectTransform.localRotation = Quaternion.identity;
            cellRectTransform.localScale = new Vector3 (1, 1, 1);

            ScrollViewCellWrapper wrapper = new ScrollViewCellWrapper (cell);
            wrapper.OnCellClick.AddListener (HandleCellClick);

            return wrapper;
        }

        /// <summary>
        /// Convenience method for setting the y position of a rect transform.
        /// </summary>
        /// <param name="transform">Transform.</param>
        /// <param name="yPosition">Y position.</param>
        private void SetTransformYPosition (RectTransform transform, float yPosition) {
            Vector3 position = transform.anchoredPosition3D;
            position.x = 0;
            position.y = yPosition;
            position.z = 0;

            transform.anchoredPosition3D = position;
        }

        /// <summary>
        /// Updates the visible rows list property with currently visible rows.
        /// </summary>
        private void UpdateVisibleRowsList () {
            visibleRows.Clear ();

            // CellHeight check avoids divide-by-zero error
            if (CellHeight == 0 || MaxPossibleVisibleRows () == 0) {
                return;
            }

            int firstVisibleRow = FirstVisibleRow ();
            int lastVisibleRow = firstVisibleRow + MaxPossibleVisibleRows () - 1;

            for (int i = firstVisibleRow; i <= lastVisibleRow; i++) {
                visibleRows.Add (i);
            }
        }

        /// <summary>
        /// Checks if the cell prefab is valid, and logs any errors.
        /// </summary>
        /// <returns><c>true</c>, if cell prefab is valid, <c>false</c> otherwise.</returns>
        private bool ValidateCellPrefab () {
            if (cellPrefab == null) {
                Debug.LogError ("Scroll view requires a cell prefab. Please add one in the Inspector.");
                return false;
            }

            RectTransform cellPrefabRectTransform = cellPrefab.GetComponent<RectTransform> ();
            if (cellPrefabRectTransform == null) {
                Debug.LogError ("Scroll view cell prefab requires a RectTransform component.");
                return false;
            }

            Button cellButton = cellPrefab.GetComponentInChildren<Button> ();
            if (cellButton == null) {
                Debug.LogWarningFormat (
                    "Scroll view cannot find a 'Button' component on the cell prefab '{0}'. " + 
                    "If you want the scroll view to respond to the reticle dwell, " +
                    "please add a 'Button' component to the prefab. " +
                    "The scroll view will automatically find the 'Button' component and use it to trigger row selection.",
                    cellPrefab.name
                );
            }

            return true;
        }

        #endregion


        #region Events

        private void HandleCellClick (int row) {
            if (controller == null) {
                Debug.LogWarningFormat (
                    "Scroll view cell at row {0} was clicked, but the scroll view controller is null. " +
                    "Please assign a scroll view controller to respond to cell clicks.",
                    row.ToString ()
                );
                return;
            }

            controller.DidSelectRow (row);
        }

        #endregion
    }
}
